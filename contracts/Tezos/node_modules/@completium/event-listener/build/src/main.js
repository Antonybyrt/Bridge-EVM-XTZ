"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stop_listener = exports.run_listener = exports.processBlock = exports.registerEvent = void 0;
const rpc_1 = require("@taquito/rpc");
const utils_1 = require("./utils");
let delay = utils_1.defaultIndexerOptions.delay;
let horizon = utils_1.defaultIndexerOptions.horizon;
let bottom = utils_1.defaultIndexerOptions.bottom;
let client = new rpc_1.RpcClient(utils_1.defaultIndexerOptions.endpoint);
let verbose = utils_1.defaultIndexerOptions.verbose;
const eventDefinitions = [];
const eventDefinitionSet = new Set();
const dump = (s) => {
    if (verbose) {
        console.log(s);
    }
};
const createEvent = (eventDef, internalOp) => {
    if (internalOp.type !== undefined && internalOp.payload !== undefined && internalOp.tag !== undefined) {
        if (eventDef.filter(internalOp.tag)) {
            return { _kind: internalOp.tag, _event: internalOp.payload };
        }
    }
    else {
        // throw new Error('Error: Malformed event')
    }
    return undefined;
};
/**
 *
 * @param s source, address of the event emitter contract
 * @param c creator, event creator function (provided by binding generator)
 * @param p processor, your event processor
 * @description Registers an event definition in indexer
 *
 */
function registerEvent({ source, filter, process }) {
    const key = source + filter.toString() + process.toString();
    if (eventDefinitionSet.has(key)) {
        return;
    }
    eventDefinitions.push({ source: source, filter: filter, process: process });
    eventDefinitionSet.add(key);
}
exports.registerEvent = registerEvent;
/**
 *
 * @param internalOp block response to process.
 * @description Executes event processors on internal operation
 *
 */
function processInternalOp(internalOp, data) {
    let apps = [];
    eventDefinitions.forEach((eventDef) => {
        if (internalOp.source === eventDef.source && internalOp.kind === rpc_1.OpKind.EVENT && internalOp.result.status === "applied") {
            const event = createEvent(eventDef, internalOp);
            if (event !== undefined) {
                apps.push({ process: eventDef.process, event: event._event, data: Object.assign(Object.assign({}, data), { source: eventDef.source, evtype: event._kind }) });
            }
        }
    });
    return apps;
}
/**
 *
 * @param block block response to process.
 * @description Processes block's internal operations
 *
 */
function processBlock(block) {
    let apps = [];
    block.operations.forEach(opentry => {
        opentry.forEach(op => {
            let data = { block: block.hash, op: op.hash, time: block.header.timestamp.toString() };
            op.contents.forEach(opcontent => {
                if (opcontent.kind === rpc_1.OpKind.TRANSACTION) {
                    const internalops = opcontent.metadata.internal_operation_results;
                    if (internalops !== undefined) {
                        internalops.forEach(internalop => {
                            apps = apps.concat(processInternalOp(internalop, data));
                        });
                    }
                }
            });
        });
    });
    return apps;
}
exports.processBlock = processBlock;
/**
 *
 * @param bottom block response to stop crawling at.
 * @description Crawls down blocks from head to bottom (bottom is NOT crawled)
 *
 */
function crawl(bottom) {
    return __awaiter(this, void 0, void 0, function* () {
        let current = yield client.getBlock({ block: `head~${horizon}` });
        let nextBottom = current.hash;
        let apps = [];
        while (bottom.hash !== current.hash && bottom.header.level < current.header.level) {
            dump("processing block " + current.hash + " ...");
            let blockApps = processBlock(current);
            apps = blockApps.concat(apps);
            current = yield client.getBlock({ block: current.header.predecessor });
        }
        apps.forEach(app => {
            app.process(app.event, app.data);
        });
        return nextBottom;
    });
}
let _stop = false;
let _running = false;
let running_bottom = undefined;
/**
 *
 * @param options indexer options
 * @description Starts the event indexer
 *
 */
function run_listener(options) {
    var _a, _b, _c, _d;
    return __awaiter(this, void 0, void 0, function* () {
        if (_running) {
            return;
        }
        _running = true;
        _stop = false;
        if (options !== undefined) {
            delay = (_a = options.delay) !== null && _a !== void 0 ? _a : delay;
            horizon = (_b = options.horizon) !== null && _b !== void 0 ? _b : horizon;
            bottom = (_c = options.bottom) !== null && _c !== void 0 ? _c : bottom;
            verbose = (_d = options.verbose) !== null && _d !== void 0 ? _d : verbose;
            if (options.endpoint !== undefined) {
                client = new rpc_1.RpcClient(options.endpoint);
            }
        }
        bottom = running_bottom !== null && running_bottom !== void 0 ? running_bottom : bottom;
        dump("Starting tezos event listener ...");
        let bottomBlock = yield client.getBlock({ block: bottom });
        do {
            let newBottom = yield crawl(bottomBlock);
            running_bottom = newBottom;
            yield (0, utils_1.sleep)(delay);
            bottomBlock = yield client.getBlock({ block: newBottom });
        } while (!_stop);
        _running = false;
        dump("Tezos event listener stopped.");
    });
}
exports.run_listener = run_listener;
function stop_listener() {
    _stop = true;
}
exports.stop_listener = stop_listener;
//# sourceMappingURL=main.js.map